<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecos de Aetherion - Luis, o Companheiro Inabal√°vel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #gameCanvas { display: block; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; 
            width: 20px; height: 20px; 
            border: 2px solid rgba(255, 255, 255, 0.8); 
            border-radius: 50%; 
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before { top: 50%; left: 0; width: 100%; height: 1px; transform: translateY(-50%); }
        #crosshair::after { left: 50%; top: 0; height: 100%; width: 1px; transform: translateX(-50%); }
        
        #dialogueBox {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85); border: 2px solid #D4AF37;
            padding: 20px; border-radius: 10px; max-width: 600px;
            color: white; display: none; pointer-events: auto;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }
        #dialogueName { color: #D4AF37; font-weight: bold; font-size: 1.2em; margin-bottom: 10px; }
        #dialogueText { font-size: 1.1em; line-height: 1.5; }
        
        #interactionPrompt {
            position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px;
            border-radius: 20px; font-size: 0.9em; display: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 1000;
        }
        #menu h1 {
            font-size: 4em; color: #D4AF37; text-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
            margin-bottom: 20px; font-weight: 300; letter-spacing: 5px;
        }
        #menu p { color: #aaa; font-size: 1.2em; margin-bottom: 40px; max-width: 600px; text-align: center; line-height: 1.6; }
        .btn {
            background: transparent; border: 2px solid #D4AF37; color: #D4AF37;
            padding: 15px 40px; font-size: 1.2em; cursor: pointer;
            transition: all 0.3s; text-transform: uppercase; letter-spacing: 2px;
            margin: 10px;
        }
        .btn:hover { background: #D4AF37; color: #1a1a2e; box-shadow: 0 0 20px rgba(212, 175, 55, 0.6); }
        
        #hud {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #hud h3 { color: #D4AF37; margin: 0 0 10px 0; font-size: 1.1em; }
        #hud p { margin: 5px 0; font-size: 0.9em; opacity: 0.9; }
        
        #luisStatus {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.7); border: 2px solid #4A90E2;
            padding: 15px; border-radius: 10px; color: white;
            display: none;
        }
        #luisStatus h3 { color: #4A90E2; margin: 0 0 10px 0; }
        
        .typing::after {
            content: '|'; animation: blink 1s infinite;
        }
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
        
        #controls {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.6); padding: 15px;
            border-radius: 10px; color: #aaa; font-size: 0.85em;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #controls span { color: #D4AF37; font-weight: bold; }
        
        #interactables {
            position: absolute; bottom: 200px; left: 20px;
            background: rgba(0, 0, 0, 0.7); padding: 15px;
            border-radius: 10px; color: white; display: none;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
    </style>
</head>
<body>

<div id="menu">
    <h1>ECOS DE AETHERION</h1>
    <p>Voc√™ n√£o √© o escolhido... Voc√™ √© quem escolhe ficar. üëä<br><br>
    Explore Valedorn, interaja com os habitantes, e descubra a hist√≥ria de Luis, 
    o companheiro que nunca abandona.</p>
    <button class="btn" onclick="startGame()">Iniciar Jornada</button>
    <div style="margin-top: 30px; color: #666; font-size: 0.9em;">
        <p>WASD - Mover | Mouse - Olhar | E - Interagir | ESC - Menu</p>
    </div>
</div>

<div id="ui">
    <div id="crosshair"></div>
    <div id="interactionPrompt">Pressione <b>E</b> para interagir</div>
    <div id="dialogueBox">
        <div id="dialogueName">Nome</div>
        <div id="dialogueText" class="typing"></div>
    </div>
    <div id="hud">
        <h3>Valedorn</h3>
        <p>üå≥ √Årvores: <span id="treeCount">0</span></p>
        <p>üè† Casas: <span id="houseCount">0</span></p>
        <p>üë• Habitantes: <span id="npcCount">0</span></p>
        <p>üêÑ Animais: <span id="animalCount">0</span></p>
    </div>
    <div id="luisStatus">
        <h3>Luis - Companheiro</h3>
        <p>Estado: <span id="luisState">Seguindo</span></p>
        <p>V√≠nculo: <span id="bondLevel">Amigo</span></p>
    </div>
    <div id="controls">
        <span>WASD</span> Mover <span>MOUSE</span> Olhar<br>
        <span>E</span> Interagir <span>ESC</span> Menu
    </div>
    <div id="interactables">
        <h4 style="color: #D4AF37; margin-top: 0;">Objetos Pr√≥ximos:</h4>
        <ul id="interactList" style="list-style: none; padding: 0;"></ul>
    </div>
</div>

<script>
// Game State
let scene, camera, renderer, controls;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let prevTime = performance.now();
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let raycaster;
let interactables = [];
let npcs = [];
let animals = [];
let houses = [];
let trees = [];
let luis;
let isGameActive = false;
let currentDialogue = null;
let dialogueIndex = 0;
let typingInterval;
let playerInHouse = false;

// Luis AI State
let luisState = 'following'; // following, idle, talking, helping
let luisDialogues = [
    "T√° com medo? Normal. Mas eu t√¥ aqui.",
    "Escolhe o que voc√™ acredita. Eu seguro as consequ√™ncias com voc√™.",
    "Prefiro ser o amigo certo... do que o rei errado.",
    "N√£o sou o her√≥i da profecia, mas nenhum her√≥i vence sozinho.",
    "Voc√™ √© quem escolhe ficar. Isso faz toda a diferen√ßa.",
    "Ei, vi uma vaca bonita l√° perto da fonte. Quer ir ver?",
    "√Äs vezes precisamos apenas de algu√©m que caminhe junto.",
    "Lembre-se: eu n√£o sou sombra, sou base."
];

// NPC Functions (30 different behaviors)
const npcFunctions = [
    "walking_dog", "carrying_groceries", "sweeping_porch", "watering_plants",
    "reading_newspaper", "fixing_fence", "chatting_neighbor", "pushing_wheelbarrow",
    "fishing", "chopping_wood", "milking_cow", "feeding_chickens", "herding_sheep",
    "painting_fence", "playing_flute", "dancing", "stretching", "bird_watching",
    "gardening", "hanging_laundry", "repairing_roof", "carving_wood", "knitting",
    "tending_fire", "writing_letter", "polishing_shoes", "combing_hair", "waving",
    "looking_at_sky", "counting_coins"
];

const npcNames = [
    "Aldric Blackwood", "Beatrice Thornberry", "Cedric Ironheart", "Dorothy Meadowbrook",
    "Edmund Stonegate", "Florence Whitmore", "Godric Crawford", "Hilda Holloway",
    "Ivan Ashford", "Josephine Westbrook", "Kenneth Northwood", "Lydia Eastwick",
    "Morton Southgate", "Nora Fairweather", "Oswald Stormborn", "Priscilla Brightblade",
    "Quentin Darkhollow", "Rosalind Lightfoot", "Silas Strongarm", "Theodora Swiftwind",
    "Ulric Deepwater", "Victoria Highhill", "Wilfred Longbridge", "Yvette Oldfield",
    "Zachary Newman", "Agatha Blackwood", "Barnaby Thornberry", "Clementine Ironheart",
    "Duncan Meadowbrook", "Eleanor Stonegate"
];

function init() {
    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 10, 150);

    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.7, 5);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Controls
    controls = new THREE.PointerLockControls(camera, document.body);
    
    controls.addEventListener('lock', () => {
        document.getElementById('menu').style.display = 'none';
        isGameActive = true;
    });
    
    controls.addEventListener('unlock', () => {
        if (isGameActive) {
            document.getElementById('menu').style.display = 'flex';
            document.querySelector('#menu h1').textContent = 'PAUSA';
            document.querySelector('#menu p').innerHTML = 'Jogo pausado. Clique para continuar.';
            document.querySelector('.btn').textContent = 'Continuar';
        }
    });

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    dirLight.castShadow = true;
    dirLight.shadow.camera.left = -100;
    dirLight.shadow.camera.right = 100;
    dirLight.shadow.camera.top = 100;
    dirLight.shadow.camera.bottom = -100;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3a7a3a });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Roads
    createRoads();

    // Raycaster
    raycaster = new THREE.Raycaster();

    // Generate World
    generateHouses();
    generateTrees();
    generateNPCs();
    generateAnimals();
    createLuis();
    createInteractables();

    // Event Listeners
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('click', onMouseClick);
    window.addEventListener('resize', onWindowResize);

    // Update HUD
    document.getElementById('treeCount').textContent = trees.length;
    document.getElementById('houseCount').textContent = houses.length;
    document.getElementById('npcCount').textContent = npcs.length;
    document.getElementById('animalCount').textContent = animals.length;

    animate();
}

function createRoads() {
    const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
    
    // Main road
    const road1 = new THREE.Mesh(new THREE.PlaneGeometry(200, 8), roadMaterial);
    road1.rotation.x = -Math.PI / 2;
    road1.position.y = 0.01;
    scene.add(road1);

    // Cross road
    const road2 = new THREE.Mesh(new THREE.PlaneGeometry(8, 200), roadMaterial);
    road2.rotation.x = -Math.PI / 2;
    road2.position.y = 0.01;
    scene.add(road2);
}

function generateHouses() {
    const houseColors = [0x8B4513, 0xA0522D, 0xCD853F, 0xD2691E, 0xDEB887];
    
    for (let i = 0; i < 25; i++) {
        const x = (Math.random() - 0.5) * 140;
        const z = (Math.random() - 0.5) * 140;
        
        // Avoid roads
        if (Math.abs(x) < 6 || Math.abs(z) < 6) continue;
        
        const houseGroup = new THREE.Group();
        houseGroup.position.set(x, 0, z);
        
        // House body
        const width = 6 + Math.random() * 4;
        const depth = 6 + Math.random() * 4;
        const height = 4 + Math.random() * 2;
        
        const bodyGeo = new THREE.BoxGeometry(width, height, depth);
        const bodyMat = new THREE.MeshLambertMaterial({ color: houseColors[Math.floor(Math.random() * houseColors.length)] });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = height / 2;
        body.castShadow = true;
        body.receiveShadow = true;
        houseGroup.add(body);
        
        // Roof
        const roofHeight = 2.5;
        const roofGeo = new THREE.ConeGeometry(Math.max(width, depth) * 0.8, roofHeight, 4);
        const roofMat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = height + roofHeight / 2;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        houseGroup.add(roof);
        
        // Door
        const doorGeo = new THREE.BoxGeometry(1.2, 2.2, 0.2);
        const doorMat = new THREE.MeshLambertMaterial({ color: 0x4a3c28 });
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.set(0, 1.1, depth / 2 + 0.1);
        houseGroup.add(door);
        
        // Windows
        const windowGeo = new THREE.BoxGeometry(1, 1, 0.1);
        const windowMat = new THREE.MeshLambertMaterial({ color: 0x87CEEB });
        
        for (let w = 0; w < 3; w++) {
            const window = new THREE.Mesh(windowGeo, windowMat);
            window.position.set((w - 1) * 2, 2.5, depth / 2 + 0.1);
            houseGroup.add(window);
        }
        
        // Chimney
        if (Math.random() > 0.5) {
            const chimGeo = new THREE.BoxGeometry(0.8, 2, 0.8);
            const chimMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const chimney = new THREE.Mesh(chimGeo, chimMat);
            chimney.position.set(width / 3, height + 1, -depth / 4);
            houseGroup.add(chimney);
        }
        
        // Interior objects (visible when entering)
        houseGroup.userData = {
            type: 'house',
            id: i,
            interior: createHouseInterior(width, height, depth)
        };
        
        scene.add(houseGroup);
        houses.push(houseGroup);
        interactables.push({ mesh: door, type: 'door', house: houseGroup });
    }
}

function createHouseInterior(width, height, depth) {
    const interior = new THREE.Group();
    
    // Sofa
    const sofaGeo = new THREE.BoxGeometry(2, 0.8, 1);
    const sofaMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
    const sofa = new THREE.Mesh(sofaGeo, sofaMat);
    sofa.position.set(-width/4, 0.4, 0);
    interior.add(sofa);
    
    // TV
    const tvGeo = new THREE.BoxGeometry(1.5, 1, 0.2);
    const tvMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
    const tv = new THREE.Mesh(tvGeo, tvMat);
    tv.position.set(0, 1.5, -depth/2 + 0.5);
    interior.add(tv);
    
    // Bed
    const bedGeo = new THREE.BoxGeometry(2, 0.6, 3);
    const bedMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
    const bed = new THREE.Mesh(bedGeo, bedMat);
    bed.position.set(width/3, 0.3, -depth/4);
    interior.add(bed);
    
    // Fridge
    const fridgeGeo = new THREE.BoxGeometry(1, 2, 1);
    const fridgeMat = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
    const fridge = new THREE.Mesh(fridgeGeo, fridgeMat);
    fridge.position.set(-width/2 + 0.6, 1, -depth/2 + 0.6);
    interior.add(fridge);
    
    return interior;
}

function generateTrees() {
    const treeTypes = ['oak', 'pine', 'birch'];
    
    for (let i = 0; i < 150; i++) {
        const x = (Math.random() - 0.5) * 190;
        const z = (Math.random() - 0.5) * 190;
        
        // Avoid village center and roads
        if ((Math.abs(x) < 20 && Math.abs(z) < 20) || Math.abs(x) < 6 || Math.abs(z) < 6) continue;
        
        const treeGroup = new THREE.Group();
        treeGroup.position.set(x, 0, z);
        
        const scale = 0.8 + Math.random() * 0.7;
        treeGroup.scale.set(scale, scale, scale);
        
        const type = treeTypes[Math.floor(Math.random() * treeTypes.length)];
        
        // Trunk
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
        const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1;
        trunk.castShadow = true;
        treeGroup.add(trunk);
        
        // Leaves based on type
        if (type === 'oak') {
            const leavesGeo = new THREE.DodecahedronGeometry(2);
            const leavesMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 3;
            leaves.castShadow = true;
            treeGroup.add(leaves);
        } else if (type === 'pine') {
            for (let j = 0; j < 3; j++) {
                const coneGeo = new THREE.ConeGeometry(2 - j * 0.4, 2, 8);
                const coneMat = new THREE.MeshLambertMaterial({ color: 0x0F4F0F });
                const cone = new THREE.Mesh(coneGeo, coneMat);
                cone.position.y = 2.5 + j * 1.2;
                cone.castShadow = true;
                treeGroup.add(cone);
            }
        } else {
            const leavesGeo = new THREE.SphereGeometry(1.8, 8, 6);
            const leavesMat = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 2.8;
            leaves.castShadow = true;
            treeGroup.add(leaves);
        }
        
        scene.add(treeGroup);
        trees.push(treeGroup);
    }
}

function generateNPCs() {
    for (let i = 0; i < 30; i++) {
        const x = (Math.random() - 0.5) * 100;
        const z = (Math.random() - 0.5) * 100;
        
        if (Math.abs(x) < 6 || Math.abs(z) < 6) continue;
        
        const npcGroup = new THREE.Group();
        npcGroup.position.set(x, 0, z);
        
        // Body
        const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.7, 8);
        const color = new THREE.Color().setHSL(Math.random(), 0.6, 0.5);
        const bodyMat = new THREE.MeshLambertMaterial({ color: color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.85;
        body.castShadow = true;
        npcGroup.add(body);
        
        // Head
        const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
        const headMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 1.8;
        npcGroup.add(head);
        
        // Arms
        const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8);
        const armMat = new THREE.MeshLambertMaterial({ color: color });
        
        const leftArm = new THREE.Mesh(armGeo, armMat);
        leftArm.position.set(-0.4, 1.2, 0);
        leftArm.rotation.z = 0.3;
        npcGroup.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeo, armMat);
        rightArm.position.set(0.4, 1.2, 0);
        rightArm.rotation.z = -0.3;
        npcGroup.add(rightArm);
        
        // Dog if applicable
        let dog = null;
        if (Math.random() > 0.7) {
            dog = createDog();
            dog.position.set(1, 0, 1);
            npcGroup.add(dog);
        }
        
        // Cart if applicable
        let cart = null;
        if (Math.random() > 0.85) {
            cart = createCart();
            cart.position.set(-1.5, 0, 0);
            npcGroup.add(cart);
        }
        
        npcGroup.userData = {
            type: 'npc',
            id: i,
            name: npcNames[i],
            function: npcFunctions[Math.floor(Math.random() * npcFunctions.length)],
            speed: 0.5 + Math.random() * 1.5,
            targetX: x + (Math.random() - 0.5) * 20,
            targetZ: z + (Math.random() - 0.5) * 20,
            waitTime: 0,
            dog: dog,
            cart: cart,
            dialogue: [
                `Ol√°, sou ${npcNames[i]}.`,
                "Valedorn √© um lugar pac√≠fico.",
                "Voc√™ √© novo por aqui?",
                "Cuidado com os lobos na floresta leste.",
                "O prefeito est√° procurando aventureiros."
            ]
        };
        
        scene.add(npcGroup);
        npcs.push(npcGroup);
        interactables.push({ mesh: body, type: 'npc', npc: npcGroup });
    }
}

function createDog() {
    const dogGroup = new THREE.Group();
    
    const bodyGeo = new THREE.BoxGeometry(0.4, 0.4, 0.8);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.3;
    dogGroup.add(body);
    
    const headGeo = new THREE.BoxGeometry(0.3, 0.3, 0.35);
    const head = new THREE.Mesh(headGeo, bodyMat);
    head.position.set(0, 0.6, 0.3);
    dogGroup.add(head);
    
    return dogGroup;
}

function createCart() {
    const cartGroup = new THREE.Group();
    
    const baseGeo = new THREE.BoxGeometry(1.2, 0.3, 1.5);
    const baseMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = 0.4;
    cartGroup.add(base);
    
    const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.1, 8);
    const wheelMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
    
    const positions = [[-0.5, 0.25, 0.5], [0.5, 0.25, 0.5], [-0.5, 0.25, -0.5], [0.5, 0.25, -0.5]];
    positions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.x = Math.PI / 2;
        wheel.position.set(...pos);
        cartGroup.add(wheel);
    });
    
    return cartGroup;
}

function generateAnimals() {
    const animalTypes = [
        { type: 'cow', color: 0xFFFFFF, size: 1.2 },
        { type: 'horse', color: 0x8B4513, size: 1.4 },
        { type: 'sheep', color: 0xF5F5DC, size: 0.8 },
        { type: 'chicken', color: 0xFFFFFF, size: 0.3 },
        { type: 'cat', color: 0xFFA500, size: 0.4 }
    ];
    
    for (let i = 0; i < 40; i++) {
        const x = (Math.random() - 0.5) * 120;
        const z = (Math.random() - 0.5) * 120;
        
        if (Math.abs(x) < 10 && Math.abs(z) < 10) continue;
        
        const animalData = animalTypes[Math.floor(Math.random() * animalTypes.length)];
        const animalGroup = new THREE.Group();
        animalGroup.position.set(x, 0, z);
        
        if (animalData.type === 'cow') {
            const bodyGeo = new THREE.BoxGeometry(1.2, 1, 2);
            const bodyMat = new THREE.MeshLambertMaterial({ color: animalData.color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.8;
            animalGroup.add(body);
            
            const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.8);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.set(0, 1.4, 1);
            animalGroup.add(head);
        } else if (animalData.type === 'horse') {
            const bodyGeo = new THREE.BoxGeometry(1, 1.2, 2.2);
            const bodyMat = new THREE.MeshLambertMaterial({ color: animalData.color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.1;
            animalGroup.add(body);
            
            const headGeo = new THREE.BoxGeometry(0.5, 0.8, 1);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.set(0, 1.8, 1.4);
            animalGroup.add(head);
        } else if (animalData.type === 'cat') {
            const bodyGeo = new THREE.BoxGeometry(0.4, 0.3, 0.7);
            const bodyMat = new THREE.MeshLambertMaterial({ color: animalData.color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.25;
            animalGroup.add(body);
        } else {
            const bodyGeo = new THREE.BoxGeometry(animalData.size, animalData.size * 0.8, animalData.size * 1.5);
            const bodyMat = new THREE.MeshLambertMaterial({ color: animalData.color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = animalData.size * 0.5;
            animalGroup.add(body);
        }
        
        animalGroup.userData = {
            type: 'animal',
            animalType: animalData.type,
            id: i,
            state: 'idle',
            timer: Math.random() * 10
        };
        
        scene.add(animalGroup);
        animals.push(animalGroup);
        interactables.push({ mesh: animalGroup.children[0], type: 'animal', animal: animalGroup });
    }
}

function createLuis() {
    luis = new THREE.Group();
    luis.position.set(2, 0, 2);
    
    // Body - White clothing
    const bodyGeo = new THREE.CylinderGeometry(0.32, 0.32, 1.7, 8);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0xF5F5F5 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.85;
    body.castShadow = true;
    luis.add(body);
    
    // Curly hair (represented with multiple spheres)
    const hairGroup = new THREE.Group();
    const hairColor = 0x2C1810;
    for (let i = 0; i < 8; i++) {
        const hairGeo = new THREE.SphereGeometry(0.12, 6, 6);
        const hairMat = new THREE.MeshLambertMaterial({ color: hairColor });
        const hair = new THREE.Mesh(hairGeo, hairMat);
        hair.position.set(
            Math.sin(i * Math.PI / 4) * 0.2,
            2 + Math.cos(i * 0.5) * 0.1,
            Math.cos(i * Math.PI / 4) * 0.2
        );
        hairGroup.add(hair);
    }
    luis.add(hairGroup);
    
    // Head
    const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xFDBCB4 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.8;
    luis.add(head);
    
    // Glasses (blue frames)
    const glassesGeo = new THREE.BoxGeometry(0.35, 0.08, 0.15);
    const glassesMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
    const glasses = new THREE.Mesh(glassesGeo, glassesMat);
    glasses.position.set(0, 1.82, 0.18);
    luis.add(glasses);
    
    // Arms
    const armGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.8);
    const armMat = new THREE.MeshLambertMaterial({ color: 0xF5F5F5 });
    
    const leftArm = new THREE.Mesh(armGeo, armMat);
    leftArm.position.set(-0.42, 1.2, 0);
    leftArm.rotation.z = 0.3;
    luis.add(leftArm);
    
    const rightArm = new THREE.Mesh(armGeo, armMat);
    rightArm.position.set(0.42, 1.2, 0);
    rightArm.rotation.z = -0.3;
    luis.add(rightArm);
    
    luis.userData = {
        type: 'luis',
        name: 'Luis',
        dialogueIndex: 0,
        following: true,
        bondLevel: 1
    };
    
    scene.add(luis);
    interactables.push({ mesh: body, type: 'luis', luis: luis });
    
    document.getElementById('luisStatus').style.display = 'block';
}

function createInteractables() {
    // Add some furniture outside
    for (let i = 0; i < 10; i++) {
        const x = (Math.random() - 0.5) * 80;
        const z = (Math.random() - 0.5) * 80;
        
        if (Math.abs(x) < 8 || Math.abs(z) < 8) continue;
        
        // Bench
        const benchGeo = new THREE.BoxGeometry(2, 0.5, 0.6);
        const benchMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const bench = new THREE.Mesh(benchGeo, benchMat);
        bench.position.set(x, 0.5, z);
        bench.castShadow = true;
        scene.add(bench);
        
        interactables.push({ mesh: bench, type: 'bench', action: 'sit' });
    }
}

function startGame() {
    controls.lock();
    document.getElementById('menu').style.display = 'none';
    isGameActive = true;
}

function onKeyDown(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = true; break;
        case 'ArrowLeft':
        case 'KeyA': moveLeft = true; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = true; break;
        case 'ArrowRight':
        case 'KeyD': moveRight = true; break;
        case 'KeyE': checkInteraction(); break;
    }
}

function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = false; break;
        case 'ArrowLeft':
        case 'KeyA': moveLeft = false; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = false; break;
        case 'ArrowRight':
        case 'KeyD': moveRight = false; break;
    }
}

function checkInteraction() {
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    
    if (intersects.length > 0) {
        const obj = intersects[0].object;
        const parent = obj.parent;
        
        // Find interactable
        const interactable = interactables.find(i => i.mesh === obj || i.mesh === parent);
        
        if (interactable) {
            const distance = intersects[0].distance;
            if (distance < 5) {
                handleInteraction(interactable);
            }
        }
    }
}

function handleInteraction(interactable) {
    switch (interactable.type) {
        case 'luis':
            talkToLuis();
            break;
        case 'npc':
            talkToNPC(interactable.npc);
            break;
        case 'animal':
            interactWithAnimal(interactable.animal);
            break;
        case 'door':
            enterHouse(interactable.house);
            break;
        case 'bench':
            sitOnBench();
            break;
    }
}

function talkToLuis() {
    if (currentDialogue) return;
    
    const dialogue = luisDialogues[Math.floor(Math.random() * luisDialogues.length)];
    showDialogue("Luis", dialogue);
    
    // Update bond
    luis.userData.bondLevel += 0.1;
    updateLuisStatus();
}

function updateLuisStatus() {
    const bond = luis.userData.bondLevel;
    let level = "Conhecido";
    if (bond > 2) level = "Amigo";
    if (bond > 5) level = "Companheiro";
    if (bond > 8) level = "Irm√£o de Alma";
    
    document.getElementById('bondLevel').textContent = level;
}

function talkToNPC(npc) {
    if (currentDialogue) return;
    
    const dialogues = npc.userData.dialogue;
    const dialogue = dialogues[Math.floor(Math.random() * dialogues.length)];
    showDialogue(npc.userData.name, dialogue);
    
    // NPC looks at player
    npc.lookAt(camera.position.x, npc.position.y, camera.position.z);
}

function interactWithAnimal(animal) {
    const type = animal.userData.animalType;
    const messages = {
        cow: ["A vaca muge suavemente.", "A vaca mastiga a grama.", "A vaca olha para voc√™ com curiosidade."],
        horse: ["O cavalo relincha.", "O cavalo sacode a crina.", "O cavalo assenta o casco."],
        sheep: ["A ovelha bala.", "A ovelha continua pastando.", "A ovelha pula levemente."],
        chicken: ["A galinha cacareja.", "A galinha bicou o ch√£o.", "A galinha abriu as asas."],
        cat: ["O gato mia.", "O gato se espregui√ßa.", "O gato ronrona."]
    };
    
    const msgs = messages[type] || ["O animal olha para voc√™."];
    showDialogue(type.charAt(0).toUpperCase() + type.slice(1), msgs[Math.floor(Math.random() * msgs.length)]);
}

function enterHouse(house) {
    if (playerInHouse) {
        // Exit house
        camera.position.set(house.position.x, 1.7, house.position.z + 8);
        playerInHouse = false;
        scene.remove(house.userData.interior);
        showDialogue("Sistema", "Voc√™ saiu da casa.");
    } else {
        // Enter house
        camera.position.set(house.position.x, 1.7, house.position.z);
        playerInHouse = true;
        house.userData.interior.position.copy(house.position);
        scene.add(house.userData.interior);
        showDialogue("Sistema", "Voc√™ entrou na casa. Pressione E na porta para sair.");
    }
}

function sitOnBench() {
    showDialogue("Sistema", "Voc√™ sentou no banco. Momento de descanso...");
}

function showDialogue(name, text) {
    currentDialogue = { name, text };
    dialogueIndex = 0;
    
    const box = document.getElementById('dialogueBox');
    const nameEl = document.getElementById('dialogueName');
    const textEl = document.getElementById('dialogueText');
    
    nameEl.textContent = name;
    box.style.display = 'block';
    textEl.textContent = '';
    
    // Typewriter effect
    let i = 0;
    clearInterval(typingInterval);
    typingInterval = setInterval(() => {
        if (i < text.length) {
            textEl.textContent += text.charAt(i);
            i++;
        } else {
            clearInterval(typingInterval);
            setTimeout(() => {
                box.style.display = 'none';
                currentDialogue = null;
            }, 3000);
        }
    }, 30);
}

function onMouseClick() {
    if (!isGameActive && document.getElementById('menu').style.display !== 'none') {
        controls.lock();
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function updateNPCs(delta) {
    npcs.forEach(npc => {
        const data = npc.userData;
        
        if (data.waitTime > 0) {
            data.waitTime -= delta;
            return;
        }
        
        // Move towards target
        const dx = data.targetX - npc.position.x;
        const dz = data.targetZ - npc.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        if (dist > 0.5) {
            npc.position.x += (dx / dist) * data.speed * delta;
            npc.position.z += (dz / dist) * data.speed * delta;
            npc.lookAt(data.targetX, npc.position.y, data.targetZ);
            
            // Animate dog if present
            if (data.dog) {
                data.dog.position.x = 1 + Math.sin(Date.now() * 0.005) * 0.2;
            }
        } else {
            // Pick new target
            data.targetX = npc.position.x + (Math.random() - 0.5) * 30;
            data.targetZ = npc.position.z + (Math.random() - 0.5) * 30;
            data.waitTime = 2 + Math.random() * 5;
            
            // Clamp to world bounds
            data.targetX = Math.max(-90, Math.min(90, data.targetX));
            data.targetZ = Math.max(-90, Math.min(90, data.targetZ));
        }
    });
}

function updateAnimals(delta) {
    animals.forEach(animal => {
        const data = animal.userData;
        data.timer -= delta;
        
        if (data.timer <= 0) {
            data.state = ['idle', 'walking', 'eating'][Math.floor(Math.random() * 3)];
            data.timer = 3 + Math.random() * 7;
            
            if (data.state === 'walking') {
                const angle = Math.random() * Math.PI * 2;
                data.targetX = animal.position.x + Math.cos(angle) * 5;
                data.targetZ = animal.position.z + Math.sin(angle) * 5;
            }
        }
        
        if (data.state === 'walking') {
            const dx = data.targetX - animal.position.x;
            const dz = data.targetZ - animal.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            if (dist > 0.3) {
                animal.position.x += (dx / dist) * 0.5 * delta;
                animal.position.z += (dz / dist) * 0.5 * delta;
                animal.lookAt(data.targetX, animal.position.y, data.targetZ);
            }
        }
    });
}

function updateLuis(delta) {
    if (!luis || !luis.userData.following) return;
    
    const playerPos = camera.position;
    const luisPos = luis.position;
    
    const dx = playerPos.x - luisPos.x;
    const dz = playerPos.z - luisPos.z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    
    // Follow player if too far
    if (dist > 3) {
        const speed = 3 * delta;
        luis.position.x += (dx / dist) * speed;
        luis.position.z += (dz / dist) * speed;
        luis.lookAt(playerPos.x, luisPos.y, playerPos.z);
        document.getElementById('luisState').textContent = 'Seguindo';
    } else if (dist < 1.5) {
        // Too close, back up
        luis.position.x -= (dx / dist) * 1 * delta;
        luis.position.z -= (dz / dist) * 1 * delta;
        document.getElementById('luisState').textContent = 'Pr√≥ximo';
    } else {
        document.getElementById('luisState').textContent = 'Pronto';
    }
}

function checkProximity() {
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    
    const prompt = document.getElementById('interactionPrompt');
    const interactablesDiv = document.getElementById('interactables');
    const interactList = document.getElementById('interactList');
    
    let nearby = [];
    
    if (intersects.length > 0 && intersects[0].distance < 5) {
        const obj = intersects[0].object;
        const parent = obj.parent;
        const interactable = interactables.find(i => i.mesh === obj || i.mesh === parent);
        
        if (interactable) {
            prompt.style.display = 'block';
            
            // Update interactables list
            let name = interactable.type;
            if (interactable.type === 'npc') name = interactable.npc.userData.name;
            if (interactable.type === 'luis') name = 'Luis';
            if (interactable.type === 'animal') name = interactable.animal.userData.animalType;
            
            nearby.push(name);
        } else {
            prompt.style.display = 'none';
        }
    } else {
        prompt.style.display = 'none';
    }
    
    // Check for nearby objects
    interactables.forEach(item => {
        let pos;
        if (item.type === 'npc') pos = item.npc.position;
        else if (item.type === 'luis') pos = item.luis.position;
        else if (item.type === 'animal') pos = item.animal.position;
        else if (item.mesh) pos = item.mesh.position;
        
        if (pos) {
            const dx = pos.x - camera.position.x;
            const dz = pos.z - camera.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            if (dist < 8 && !nearby.includes(item.type)) {
                let name = item.type;
                if (item.type === 'npc') name = item.npc.userData.name;
                if (item.type === 'luis') name = 'Luis';
                if (item.type === 'animal') name = item.animal.userData.animalType;
                nearby.push(name);
            }
        }
    });
    
    if (nearby.length > 0) {
        interactablesDiv.style.display = 'block';
        interactList.innerHTML = nearby.map(n => `<li style="padding: 3px 0;">‚Ä¢ ${n}</li>`).join('');
    } else {
        interactablesDiv.style.display = 'none';
    }
}

function animate() {
    requestAnimationFrame(animate);
    
    if (!isGameActive) {
        renderer.render(scene, camera);
        return;
    }
    
    const time = performance.now();
    const delta = (time - prevTime) / 1000;
    
    // Movement
    if (controls.isLocked) {
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();
        
        if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;
        
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        
        // Keep player on ground
        camera.position.y = playerInHouse ? 1.7 : 1.7;
    }
    
    // Update entities
    updateNPCs(delta);
    updateAnimals(delta);
    updateLuis(delta);
    checkProximity();
    
    prevTime = time;
    renderer.render(scene, camera);
}

// Initialize when page loads
window.addEventListener('load', init);
</script>

</body>
</html>
